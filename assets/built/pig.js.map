{"version":3,"sources":["pig.js"],"names":["global","optimizedResize","callbacks","running","resize","window","requestAnimationFrame","runCallbacks","setTimeout","forEach","callback","add","length","addEventListener","push","disable","removeEventListener","reEnable","Pig","imageData","options","containerId","classPrefix","transitionSpeed","css","head","style","this","inRAF","isTransitioning","minAspectRatioRequiresTransition","minAspectRatio","latestYOffset","lastWindowWidth","innerWidth","scrollDirection","visibleImages","settings","figureTagName","spaceBetweenImages","primaryImageBufferHeight","secondaryImageBufferHeight","thumbnailSize","urlForSize","filename","size","getMinAspectRatio","getImageSize","obj1","obj2","i","hasOwnProperty","_extend","container","document","getElementById","console","error","images","_parseImageData","getElementsByTagName","createElement","type","styleSheet","cssText","appendChild","createTextNode","ProgressiveImage","singleImageData","index","pig","existsOnPage","aspectRatio","classNames","figure","thumbnail","loaded","prototype","_getTransitionTimeout","_getTransitionString","_recomputeMinAspectRatio","oldMinAspectRatio","progressiveImages","image","progressiveImage","bind","_computeLayout","wrapperWidth","parseInt","clientWidth","row","translateX","translateY","rowAspectRatio","transition","call","parseFloat","Math","max","rowHeight","img","imageWidth","width","height","totalHeight","_doLayout","bufferTop","bufferBottom","containerOffset","elem","offsetTop","isNaN","offsetParent","_getOffsetTop","windowHeight","innerHeight","minTranslateYPlusHeight","maxTranslateY","hide","load","_getOnScroll","_this","newYOffset","pageYOffset","previousYOffset","enable","onScroll","_updateStyles","getElement","Image","src","className","onload","fullImage","removeChild","element","setAttribute","transform","define","amd","module","exports"],"mappings":"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","file":"pig.js","sourcesContent":["(function(global) {\n    'use strict';\n\n    /**\n     * This is a manager for our resize handlers. You can add a callback, disable\n     * all resize handlers, and re-enable handlers after they have been disabled.\n     *\n     * optimizedResize is adapted from Mozilla code:\n     * https://developer.mozilla.org/en-US/docs/Web/Events/resize\n     */\n    var optimizedResize = (function() {\n        var callbacks = [];\n        var running = false;\n\n        // fired on resize event\n        function resize() {\n            if (!running) {\n                running = true;\n                if (window.requestAnimationFrame) {\n                    window.requestAnimationFrame(runCallbacks);\n                } else {\n                    setTimeout(runCallbacks, 66);\n                }\n            }\n        }\n\n        // run the actual callbacks\n        function runCallbacks() {\n            callbacks.forEach(function(callback) {\n                callback();\n            });\n\n            running = false;\n        }\n\n        return {\n            /**\n             * Add a callback to be run on resize.\n             *\n             * @param {function} callback - the callback to run on resize.\n             */\n            add: function(callback) {\n                if (!callbacks.length) {\n                    window.addEventListener('resize', resize);\n                }\n\n                callbacks.push(callback);\n            },\n\n            /**\n             * Disables all resize handlers.\n             */\n            disable: function() {\n                window.removeEventListener('resize', resize);\n            },\n\n            /**\n             * Enables all resize handlers, if they were disabled.\n             */\n            reEnable: function() {\n                window.addEventListener('resize', resize);\n            },\n        };\n    }());\n\n    /**\n     * Inject CSS needed to make the grid work in the <head></head>.\n     *\n     * @param {string} classPrefix - the prefix associated with this library that\n     *                               should be prepended to classnames.\n     * @param {string} containerId - ID of the container for the images.\n     */\n    function _injectStyle(containerId, classPrefix, transitionSpeed) {\n\n        var css = (\n            '#' + containerId + ' {' +\n            '  position: relative;' +\n            '}' +\n            '.' + classPrefix + '-figure {' +\n            '  background-color: #D5D5D5;' +\n            '  overflow: hidden;' +\n            '  left: 0;' +\n            '  position: absolute;' +\n            '  top: 0;' +\n            '  margin: 0;' +\n            '}' +\n            '.' + classPrefix + '-figure img {' +\n            '  left: 0;' +\n            '  position: absolute;' +\n            '  top: 0;' +\n            '  height: 100%;' +\n            '  width: 100%;' +\n            '  opacity: 0;' +\n            '  transition: ' + (transitionSpeed / 1000) + 's ease opacity;' +\n            '  -webkit-transition: ' + (transitionSpeed / 1000) + 's ease opacity;' +\n            '}' +\n            '.' + classPrefix + '-figure img.' + classPrefix + '-thumbnail {' +\n            '  -webkit-filter: blur(30px);' +\n            '  filter: blur(30px);' +\n            '  left: auto;' +\n            '  position: relative;' +\n            '  width: auto;' +\n            '}' +\n            '.' + classPrefix + '-figure img.' + classPrefix + '-loaded {' +\n            '  opacity: 1;' +\n            '}'\n        );\n\n        var head = document.head || document.getElementsByTagName(\"head\")[0];\n        var style = document.createElement(\"style\");\n\n        style.type = \"text/css\";\n        if (style.styleSheet) {\n            style.styleSheet.cssText = css;\n        } else {\n            style.appendChild(document.createTextNode(css));\n        }\n\n        head.appendChild(style);\n    }\n\n    /**\n     * Extend obj1 with each key in obj2, overriding default values in obj1 with\n     * values in obj2\n     *\n     * @param {object} obj1 - The object to extend.\n     * @param {object} obj2 - The overrides to apply onto obj1.\n     */\n    function _extend(obj1, obj2) {\n        for (var i in obj2) {\n            if (obj2.hasOwnProperty(i)) {\n                obj1[i] = obj2[i];\n            }\n        }\n    }\n\n    /**\n     * Returns the distance from `elem` to the top of the page. This is done by\n     * walking up the node tree, getting the offsetTop of each parent node, until\n     * the top of the page.\n     *\n     * @param {object} elem - The element to compute the offset of.\n     **/\n    function _getOffsetTop(elem){\n        var offsetTop = 0;\n        do {\n            if (!isNaN(elem.offsetTop)){\n                offsetTop += elem.offsetTop;\n            }\n            elem = elem.offsetParent;\n        } while(elem);\n        return offsetTop;\n    }\n\n    /**\n     * Creates an instance of the progressive image grid, inserting boilerplate\n     * CSS and loading image data. Instantiating an instance of the Pig class\n     * does not cause any images to appear however. After instantiating, call the\n     * `enable()` function on the returned instance:\n     *\n     *   var pig = new Pig(imageData, opts);\n     *   pig.enable();\n     *\n     * @param {array} imageData - An array of metadata about each image to\n     *                            include in the grid.\n     * @param {string} imageData[0].filename - The filename of the image.\n     * @param {string} imageData[0].aspectRatio - The aspect ratio of the image.\n     * @param {object} options - An object containing overrides for the default\n     *                           options. See below for the full list of options\n     *                           and defaults.\n     *\n     * @returns {object} The Pig instance.\n     */\n    function Pig(imageData, options) {\n        // Global State\n        this.inRAF = false;\n        this.isTransitioning = false;\n        this.minAspectRatioRequiresTransition = false;\n        this.minAspectRatio = null;\n        this.latestYOffset = 0;\n        this.lastWindowWidth = window.innerWidth;\n        this.scrollDirection = 'down';\n\n        // List of images that are loading or completely loaded on screen.\n        this.visibleImages = [];\n\n        // These are the default settings, which may be overridden.\n        this.settings = {\n\n            /**\n             * Type: string\n             * Default: 'pig'\n             * Description: The class name of the element inside of which images should\n             *   be loaded.\n             */\n            containerId: 'pig',\n\n            /**\n             * Type: string\n             * Default: 'pig'\n             * Description: The prefix associated with this library that should be\n             *   prepended to class names within the grid.\n             */\n            classPrefix: 'pig',\n\n            /**\n             * Type: string\n             * Default: 'figure'\n             * Description: The tag name to use for each figure. The default setting is\n             *   to use a <figure></figure> tag.\n             */\n            figureTagName: 'figure',\n\n            /**\n             * Type: Number\n             * Default: 8\n             * Description: Size in pixels of the gap between images in the grid.\n             */\n            spaceBetweenImages: 8,\n\n            /**\n             * Type: Number\n             * Default: 500\n             * Description: Transition speed in milliseconds\n             */\n            transitionSpeed: 500,\n\n            /**\n             * Type: Number\n             * Default: 3000\n             * Description: Height in pixels of images to preload in the direction\n             *   that the user is scrolling. For example, in the default case, if the\n             *   user is scrolling down, 1000px worth of images will be loaded below\n             *   the viewport.\n             */\n            primaryImageBufferHeight: 1000,\n\n            /**\n             * Type: Number\n             * Default: 100\n             * Description: Height in pixels of images to preload in the direction\n             *   that the user is NOT scrolling. For example, in the default case, if\n             *   the user is scrolling down, 300px worth of images will be loaded\n             *   above the viewport.  Images further up will be removed.\n             */\n            secondaryImageBufferHeight: 300,\n\n            /**\n             * Type: Number\n             * Default: 20\n             * Description: The height in pixels of the thumbnail that should be\n             *   loaded and blurred to give the effect that images are loading out of\n             *   focus and then coming into focus.\n             */\n            thumbnailSize: 20,\n\n            /**\n             * Get the URL for an image with the given filename & size.\n             *\n             * @param {string} filename - The filename of the image.\n             * @param {Number} size - The size (height in pixels) of the image.\n             *\n             * @returns {string} The URL of the image at the given size.\n             */\n            urlForSize: function(filename, size) {\n                return '/img/' + size + '/' + filename;\n            },\n\n            /**\n             * Get the minimum required aspect ratio for a valid row of images. The\n             * perfect rows are maintained by building up a row of images by adding\n             * together their aspect ratios (the aspect ratio when they are placed\n             * next to each other) until that aspect ratio exceeds the value returned\n             * by this function. Responsive reordering is achieved through changes\n             * to what this function returns at different values of the passed\n             * parameter `lastWindowWidth`.\n             *\n             * @param {Number} lastWindowWidth - The last computed width of the\n             *                                   browser window.\n             *\n             * @returns {Number} The minimum aspect ratio at this window width.\n             */\n            getMinAspectRatio: function(lastWindowWidth) {\n                if (lastWindowWidth <= 640)\n                    return 2;\n                else if (lastWindowWidth <= 1280)\n                    return 4;\n                else if (lastWindowWidth <= 1920)\n                    return 5;\n                return 6;\n            },\n\n            /**\n             * Get the image size (height in pixels) to use for this window width.\n             * Responsive resizing of images is achieved through changes to what this\n             * function returns at different values of the passed parameter\n             * `lastWindowWidth`.\n             *\n             * @param {Number} lastWindowWidth - The last computed width of the\n             *                                   browser window.\n             *\n             * @returns {Number} The size (height in pixels) of the images to load.\n             */\n            getImageSize: function(lastWindowWidth) {\n                if (lastWindowWidth <= 640)\n                    return 100;\n                else if (lastWindowWidth <= 1920)\n                    return 250;\n                return 500;\n            }\n        };\n\n        // We extend the default settings with the provided overrides.\n        _extend(this.settings, options || {});\n\n        // Find the container to load images into, if it exists.\n        this.container = document.getElementById(this.settings.containerId);\n        if (!this.container) {\n            console.error('Could not find element with ID ' + this.settings.containerId);\n        }\n\n        // Our global reference for images in the grid.  Note that not all of these\n        // images are necessarily in view or loaded.\n        this.images = this._parseImageData(imageData);\n\n        // Inject our boilerplate CSS.\n        _injectStyle(this.settings.containerId, this.settings.classPrefix, this.settings.transitionSpeed);\n\n        // Allows for chaining with `enable()`.\n        return this;\n    }\n\n    /**\n     * Because we may be transitioning a very large number of elements on a\n     * resize, and because we cannot reliably determine when all elements are\n     * done transitioning, we have to approximate the amount of time it will take\n     * for the browser to be expected to complete with a transition. This\n     * constant gives the scale factor to apply to the given transition time. For\n     * example, if transitionTimeoutScaleFactor is 1.5 and transition speed is\n     * given as 500ms, we will wait 750ms before assuming that we are actually\n     * done resizing.\n     *\n     * @returns {Number} Time in milliseconds before we can consider a resize to\n     *   have been completed.\n     */\n    Pig.prototype._getTransitionTimeout = function() {\n        var transitionTimeoutScaleFactor = 1.5;\n        return this.settings.transitionSpeed * transitionTimeoutScaleFactor;\n    };\n\n    /**\n     * Gives the CSS property string to set for the transition value, depending\n     * on whether or not we are transitioning.\n     *\n     * @returns {string} a value for the `transition` CSS property.\n     */\n    Pig.prototype._getTransitionString = function() {\n        if (this.isTransitioning) {\n            return (this.settings.transitionSpeed / 1000) + 's transform ease';\n        }\n\n        return 'none';\n    };\n\n    /**\n     * Computes the current value for `this.minAspectRatio`, using the\n     * `getMinAspectRatio` function defined in the settings. Then,\n     * `this.minAspectRatioRequiresTransition` will be set, depending on whether\n     * or not the value of this.minAspectRatio has changed.\n     */\n    Pig.prototype._recomputeMinAspectRatio = function() {\n        var oldMinAspectRatio = this.minAspectRatio;\n        this.minAspectRatio = this.settings.getMinAspectRatio(this.lastWindowWidth);\n\n        if (oldMinAspectRatio !== null && oldMinAspectRatio !== this.minAspectRatio)\n            this.minAspectRatioRequiresTransition = true;\n        else\n            this.minAspectRatioRequiresTransition = false;\n    };\n\n    /**\n     * Creates new instances of the ProgressiveImage class for each of the images\n     * defined in `imageData`.\n     *\n     * @param {array} imageData - An array of metadata about each image to\n     *                            include in the grid.\n     * @param {string} imageData[0].filename - The filename of the image.\n     * @param {string} imageData[0].aspectRatio - The aspect ratio of the image.\n     *\n     * @returns {Array[ProgressiveImage]} - An array of ProgressiveImage\n     *                                      instances that we created.\n     */\n    Pig.prototype._parseImageData = function(imageData) {\n        var progressiveImages = [];\n\n        imageData.forEach(function(image, index) {\n            var progressiveImage = new ProgressiveImage(image, index, this);\n            progressiveImages.push(progressiveImage);\n        }.bind(this));\n\n        return progressiveImages;\n    };\n\n    /**\n     * This computes the layout of the entire grid, setting the height, width,\n     * translateX, translateY, and transtion values for each ProgessiveImage in\n     * `this.images`. These styles are set on the ProgressiveImage.style property,\n     * but are not set on the DOM.\n     *\n     * This separation of concerns (computing layout and DOM manipulation) is\n     * paramount to the performance of the PIG. While we need to manipulate the\n     * DOM every time we scroll (adding or remove images, etc.), we only need to\n     * compute the layout of the PIG on load and on resize. Therefore, this\n     * function will compute the entire grid layout but will not manipulate the\n     * DOM at all.\n     *\n     * All DOM manipulation occurs in `_doLayout`.\n     */\n    Pig.prototype._computeLayout = function() {\n        // Constants\n        var wrapperWidth = parseInt(this.container.clientWidth);\n\n        // State\n        var row = [];           // The list of images in the current row.\n        var translateX = 0;     // The current translateX value that we are at\n        var translateY = 0;     // The current translateY value that we are at\n        var rowAspectRatio = 0; // The aspect ratio of the row we are building\n\n        // Compute the minimum aspect ratio that should be applied to the rows.\n        this._recomputeMinAspectRatio();\n\n        // If we are not currently transitioning, and our minAspectRatio has just\n        // changed, then we mark isTransitioning true. If this is the case, then\n        // `this._getTransitionString()` will ensure that each image has a value\n        // like \"0.5s ease all\". This will cause images to animate as they change\n        // position. (They need to change position because the minAspectRatio has\n        // changed.) Once we determine that the transtion is probably over (using\n        // `this._getTransitionTimeout`) we unset `this.isTransitioning`, so that\n        // future calls to `_computeLayout` will set \"transition: none\".\n        if (!this.isTransitioning && this.minAspectRatioRequiresTransition) {\n            this.isTransitioning = true;\n            setTimeout(function() {\n                this.isTransitioning = false;\n            }, this._getTransitionTimeout());\n        }\n\n        // Get the valid-CSS transition string.\n        var transition = this._getTransitionString();\n\n        // Loop through all our images, building them up into rows and computing\n        // the working rowAspectRatio.\n        [].forEach.call(this.images, function(image, index) {\n            rowAspectRatio += parseFloat(image.aspectRatio);\n            row.push(image);\n\n            // When the rowAspectRatio exceeeds the minimum acceptable aspect ratio,\n            // or when we're out of images, we say that we have all the images we\n            // need for this row, and compute the style values for each of these\n            // images.\n            if (rowAspectRatio >= this.minAspectRatio || index + 1 === this.images.length) {\n\n                // Make sure that the last row also has a reasonable height\n                rowAspectRatio = Math.max(rowAspectRatio, this.minAspectRatio);\n\n                // Compute this row's height.\n                var totalDesiredWidthOfImages = wrapperWidth - this.settings.spaceBetweenImages * (row.length - 1);\n                var rowHeight = totalDesiredWidthOfImages / rowAspectRatio;\n\n                // For each image in the row, compute the width, height, translateX,\n                // and translateY values, and set them (and the transition value we\n                // found above) on each image.\n                //\n                // NOTE: This does not manipulate the DOM, rather it just sets the\n                //       style values on the ProgressiveImage instance. The DOM nodes\n                //       will be updated in _doLayout.\n                row.forEach(function(img) {\n\n                    var imageWidth = rowHeight * img.aspectRatio;\n\n                    // This is NOT DOM manipulation.\n                    img.style = {\n                        width: parseInt(imageWidth),\n                        height: parseInt(rowHeight),\n                        translateX: translateX,\n                        translateY: translateY,\n                        transition: transition,\n                    };\n\n                    // The next image is this.settings.spaceBetweenImages pixels to the\n                    // right of this image.\n                    translateX += imageWidth + this.settings.spaceBetweenImages;\n\n                }.bind(this));\n\n                // Reset our state variables for next row.\n                row = [];\n                rowAspectRatio = 0;\n                translateY += parseInt(rowHeight) + this.settings.spaceBetweenImages;\n                translateX = 0;\n            }\n        }.bind(this));\n\n        // No space below the last image\n        this.totalHeight = translateY - this.settings.spaceBetweenImages;\n    };\n\n\n    /**\n     * Update the DOM to reflect the style values of each image in the PIG,\n     * adding or removing images appropriately.\n     *\n     * PIG ensures that there are not too many images loaded into the DOM at once\n     * by maintaining a buffer region around the viewport in which images are\n     * allowed, removing all images below and above. Because all of our layout\n     * is computed using CSS transforms, removing an image above the buffer will\n     * not cause the gird to reshuffle.\n     *\n     * The primary buffer is the buffer in the direction of the user's scrolling.\n     * (Below if they are scrolling down, above if they are scrolling up.) The\n     * size of this buffer determines the experience of scrolling down the page.\n     *\n     * The secondary buffer is the buffer in the opposite direction of the user's\n     * scrolling.  The size of this buffer determines the experience of changing\n     * scroll directions. (Too small, and we have to reload a ton of images above\n     * the viewport if the user changes scroll directions.)\n     *\n     * While the entire grid has been computed, only images within the viewport,\n     * the primary buffer, and the secondary buffer will exist in the DOM.\n     *\n     *\n     *             Illustration: the primary and secondary buffers\n     *\n     *\n     * +---------------------------+\n     * |                           |\n     * |                           |\n     * |                           |\n     * |                           |\n     * + - - - - - - - - - - - - - +                   -------\n     * |                           |                      A\n     * |     Secondary Buffer      |   this.setting.secondaryImageBufferHeight\n     * |                           |                      V\n     * +---------------------------+                   -------\n     * |                           |                      A\n     * |                           |                      |\n     * |                           |                      |\n     * |        Viewport           |              window.innerHeight\n     * |                           |                      |\n     * |                           |                      |\n     * |                           |                      V\n     * +---------------------------+                   -------\n     * |                           |                      A\n     * |                           |                      |\n     * |                           |                      |\n     * |                           |                      |\n     * |      Primary Buffer       |    this.settings.primaryImageBufferHeight\n     * |                           |                      |\n     * |                           |                      |\n     * |                           |                      |\n     * |                           |                      V\n     * + - - - - - - - - - - - - - +                   -------\n     * |                           |\n     * |    (Scroll direction)     |\n     * |            |              |\n     * |            |              |\n     * |            V              |\n     * |                           |\n     *\n     */\n    Pig.prototype._doLayout = function() {\n\n        // Set the container height\n        this.container.style.height = this.totalHeight + 'px';\n\n        // Get the top and bottom buffers heights.\n        var bufferTop =\n            (this.scrollDirection === 'up') ?\n                this.settings.primaryImageBufferHeight :\n                this.settings.secondaryImageBufferHeight;\n        var bufferBottom =\n            (this.scrollDirection === 'down') ?\n                this.settings.secondaryImageBufferHeight :\n                this.settings.primaryImageBufferHeight;\n\n        // Now we compute the location of the top and bottom buffers:\n        var containerOffset = _getOffsetTop(this.container);\n        var windowHeight = window.innerHeight;\n\n        // This is the top of the top buffer. If the bottom of an image is above\n        // this line, it will be removed.\n        var minTranslateYPlusHeight = this.latestYOffset - containerOffset - bufferTop;\n\n        // This is the bottom of the bottom buffer.  If the top of an image is\n        // below this line, it will be removed.\n        var maxTranslateY = this.latestYOffset - containerOffset + windowHeight + bufferBottom;\n\n        // Here, we loop over every image, determine if it is inside our buffers or\n        // no, and either insert it or remove it appropriately.\n        this.images.forEach(function(image) {\n\n            if (image.style.translateY + image.style.height < minTranslateYPlusHeight ||\n                image.style.translateY > maxTranslateY) {\n                // Hide Image\n                image.hide();\n            } else {\n                // Load Image\n                image.load();\n            }\n        }.bind(this));\n    };\n\n    /**\n     * Create our onScroll handler and return it.\n     *\n     * @returns {function} Our optimized onScroll handler.\n     */\n    Pig.prototype._getOnScroll = function() {\n        var _this = this;\n\n        /**\n         * This function is called on scroll. It computes variables about the page\n         * position and scroll direction, and then calls a _doLayout guarded by a\n         * window.requestAnimationFrame.\n         *\n         * We use the boolean variable _this.inRAF to ensure that we don't overload\n         * the number of layouts we perform by starting another layout while we are\n         * in the middle of doing one.\n         *\n         * @returns {function} The onScroll handler that we should attach.\n         */\n        var onScroll = function() {\n            // Compute the scroll direction using the latestYOffset and the\n            // previousYOffset\n            var newYOffset = window.pageYOffset;\n            _this.previousYOffset = _this.latestYOffset || newYOffset;\n            _this.latestYOffset = newYOffset;\n            _this.scrollDirection = (_this.latestYOffset > _this.previousYOffset) ? 'down' : 'up';\n\n            // Call _this.doLayout, guarded by window.requestAnimationFrame\n            if (!_this.inRAF) {\n                _this.inRAF = true;\n                window.requestAnimationFrame(function() {\n                    _this._doLayout();\n                    _this.inRAF = false;\n                });\n            }\n        };\n\n        return onScroll;\n    };\n\n    /**\n     * Enable scroll and resize handlers, and run a complete layout computation /\n     * application.\n     *\n     * @returns {object} The Pig instance, for easy chaining with the constructor.\n     */\n    Pig.prototype.enable = function() {\n        this.onScroll = this._getOnScroll();\n        window.addEventListener('scroll', this.onScroll);\n\n        this.onScroll();\n        this._computeLayout();\n        this._doLayout();\n\n        optimizedResize.add(function() {\n            this.lastWindowWidth = window.innerWidth;\n            this._computeLayout();\n            this._doLayout();\n        }.bind(this));\n\n        return this;\n    };\n\n    /**\n     * Remove all scroll and resize listeners.\n     *\n     * @returns {object} The Pig instance.\n     */\n    Pig.prototype.disable = function() {\n        window.removeEventListener('scroll', this.onScroll);\n        optimizedResize.disable();\n        return this;\n    };\n\n    /**\n     * This class manages a single image. It keeps track of the image's height,\n     * width, and position in the grid. An instance of this class is associated\n     * with a single image figure, which looks like this:\n     *\n     *   <figure class=\"pig-figure\" style=\"transform: ...\">\n     *     <img class=\"pig-thumbnail pig-loaded\" src=\"/path/to/thumbnail/image.jpg\" />\n     *     <img class=\"pig-loaded\" src=\"/path/to/500px/image.jpg\" />\n     *   </figure>\n     *\n     * However, this element may or may not actually exist in the DOM. The actual\n     * DOM element may loaded and unloaded depending on where it is with respect\n     * to the viewport. This class is responsible for managing the DOM elements,\n     * but does not include logic to determine _when_ the DOM elements should\n     * be removed.\n     *\n     * This class also manages the blur-into-focus load effect.  First, the\n     * <figure> element is inserted into the page. Then, a very small thumbnail\n     * is loaded, stretched out to the full size of the image.  This pixelated\n     * image is then blurred using CSS filter: blur(). Then, the full image is\n     * loaded, with opacity:0.  Once it has loaded, it is given the `pig-loaded`\n     * class, and its opacity is set to 1.  This creates an effect where there is\n     * first a blurred version of the image, and then it appears to come into\n     * focus.\n     *\n     * @param {array} singleImageData - An array of metadata about each image to\n     *                                  include in the grid.\n     * @param {string} singleImageData[0].filename - The filename of the image.\n     * @param {string} singleImageData[0].aspectRatio - The aspect ratio of the\n     *                                                  image.\n     */\n    function ProgressiveImage(singleImageData, index, pig) {\n\n        // Global State\n        this.existsOnPage = false; // True if the element exists on the page.\n\n        // Instance information\n        this.aspectRatio = singleImageData.aspectRatio;  // Aspect Ratio\n        this.filename = singleImageData.filename;  // Filename\n        this.index = index;  // The index in the list of images\n\n        // The Pig instance\n        this.pig = pig;\n\n        this.classNames = {\n            figure: pig.settings.classPrefix + '-figure',\n            thumbnail: pig.settings.classPrefix + '-thumbnail',\n            loaded: pig.settings.classPrefix + '-loaded',\n        };\n\n        return this;\n    }\n\n    /**\n     * Load the image element associated with this ProgressiveImage into the DOM.\n     *\n     * This function will append the figure into the DOM, create and insert the\n     * thumbnail, and create and insert the full image.\n     */\n    ProgressiveImage.prototype.load = function() {\n        // Create a new image element, and insert it into the DOM. It doesn't\n        // matter the order of the figure elements, because all positioning\n        // is done using transforms.\n        this.existsOnPage = true;\n        this._updateStyles();\n        this.pig.container.appendChild(this.getElement());\n\n        // We run the rest of the function in a 100ms setTimeout so that if the\n        // user is scrolling down the page very fast and hide() is called within\n        // 100ms of load(), the hide() function will set this.existsOnPage to false\n        // and we can exit.\n        setTimeout(function() {\n\n            // The image was hidden very quickly after being loaded, so don't bother\n            // loading it at all.\n            if (!this.existsOnPage) {\n                return;\n            }\n\n            // Show thumbnail\n            if (!this.thumbnail) {\n                this.thumbnail = new Image();\n                this.thumbnail.src = this.pig.settings.urlForSize(this.filename, this.pig.settings.thumbnailSize);\n                this.thumbnail.className = this.classNames.thumbnail;\n                this.thumbnail.onload = function() {\n\n                    // We have to make sure thumbnail still exists, we may have already been\n                    // deallocated if the user scrolls too fast.\n                    if (this.thumbnail) {\n                        this.thumbnail.className += ' ' + this.classNames.loaded;\n                    }\n                }.bind(this);\n\n                this.getElement().appendChild(this.thumbnail);\n            }\n\n            // Show full image\n            if (!this.fullImage) {\n                this.fullImage = new Image();\n                this.fullImage.src = this.pig.settings.urlForSize(this.filename, this.pig.settings.getImageSize(this.pig.lastWindowWidth));\n                this.fullImage.onload = function() {\n\n                    // We have to make sure fullImage still exists, we may have already been\n                    // deallocated if the user scrolls too fast.\n                    if (this.fullImage) {\n                        this.fullImage.className += ' ' + this.classNames.loaded;\n                    }\n                }.bind(this);\n\n                this.getElement().appendChild(this.fullImage);\n            }\n        }.bind(this), 100);\n    };\n\n    /**\n     * Removes the figure from the DOM, removes the thumbnail and full image, and\n     * deletes the this.thumbnail and this.fullImage properties off of the\n     * ProgressiveImage object.\n     */\n    ProgressiveImage.prototype.hide = function() {\n        // Remove the images from the element, so that if a user is scrolling super\n        // fast, we won't try to load every image we scroll past.\n        if (this.getElement()) {\n            if (this.thumbnail) {\n                this.thumbnail.src = '';\n                this.getElement().removeChild(this.thumbnail);\n                delete this.thumbnail;\n            }\n\n            if (this.fullImage) {\n                this.fullImage.src = '';\n                this.getElement().removeChild(this.fullImage);\n                delete this.fullImage;\n            }\n        }\n\n        // Remove the image from the DOM.\n        if (this.existsOnPage) {\n            this.pig.container.removeChild(this.getElement());\n        }\n\n        this.existsOnPage = false;\n\n    };\n\n    /**\n     * Get the DOM element associated with this ProgressiveImage. We default to\n     * using this.element, and we create it if it doesn't exist.\n     *\n     * @returns {HTMLElement} The DOM element associated with this instance.\n     */\n    ProgressiveImage.prototype.getElement = function() {\n        if (!this.element) {\n            // Changed this to allow for fancybox gallery\n            this.element = document.createElement(\"a\");\n            this.element.setAttribute(\"data-fancybox\", \"full-gallery\");\n            this.element.setAttribute(\"href\", this.pig.settings.urlForSize(this.filename, 'full'));\n            this.element.className = this.classNames.figure;\n            this._updateStyles();\n        }\n\n        return this.element;\n    };\n\n    /**\n     * Updates the style attribute to reflect this style property on this object.\n     */\n    ProgressiveImage.prototype._updateStyles = function() {\n        this.getElement().style.transition = this.style.transition;\n        this.getElement().style.width = this.style.width + 'px';\n        this.getElement().style.height = this.style.height + 'px';\n        this.getElement().style.transform = (\n            'translate3d(' + this.style.translateX + 'px,' +\n            this.style.translateY + 'px, 0)');\n    };\n\n    // Export Pig into the global scope.\n    if (typeof define === 'function' && define.amd) {\n        define(Pig);\n    } else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = Pig;\n    } else {\n        global.Pig = Pig;\n    }\n\n}(this));\n"],"sourceRoot":"/source/"}